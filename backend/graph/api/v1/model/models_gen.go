// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type File interface {
	IsFile()
	GetID() string
	GetURL() string
}

type AudioFile struct {
	ID  string `json:"id"`
	URL string `json:"url"`
}

func (AudioFile) IsFile()             {}
func (this AudioFile) GetID() string  { return this.ID }
func (this AudioFile) GetURL() string { return this.URL }

type Collection struct {
	ID             string                   `json:"id"`
	Title          *LocalizedString         `json:"title"`
	Description    *LocalizedString         `json:"description"`
	Key            string                   `json:"key"`
	DefaultContent CollectionDefaultContent `json:"defaultContent"`
	DefaultSort    CollectionDefaultSort    `json:"defaultSort"`
}

type Contributor struct {
	ID            string           `json:"id"`
	DisplayName   string           `json:"displayName"`
	Subtitle      *string          `json:"subtitle"`
	BirthYear     *int             `json:"birthYear"`
	OriginCountry *string          `json:"originCountry"`
	Image         *string          `json:"image"`
	Biography     *LocalizedString `json:"biography"`
}

type LocalizedString struct {
	Value     string   `json:"value"`
	Language  string   `json:"language"`
	Available []string `json:"available"`
}

type Participant struct {
	ID          string          `json:"id"`
	Type        ParticipantType `json:"type"`
	Contributor *Contributor    `json:"contributor"`
}

type Sheet struct {
	ID          string             `json:"id"`
	FileType    SheetFileType      `json:"fileType"`
	ContentType SheetContent       `json:"contentType"`
	Instruments []string           `json:"instruments"`
	Render      *SheetRenderResult `json:"render"`
}

type SheetRenderOptions struct {
	Clef          *SheetClef `json:"clef"`
	Instruments   []string   `json:"instruments"`
	Size          *SheetSize `json:"size"`
	Transposition *int       `json:"transposition"`
}

type SheetRenderResult struct {
	Parts []string `json:"parts"`
}

type Song struct {
	ID           string            `json:"id"`
	Status       Status            `json:"status"`
	Title        *LocalizedString  `json:"title"`
	Collections  []*SongCollection `json:"collections"`
	Details      *LocalizedString  `json:"details"`
	Participants []*Participant    `json:"participants"`
	AudioFiles   []*AudioFile      `json:"audioFiles"`
	Sheets       []*Sheet          `json:"sheets"`
}

type SongCollection struct {
	ID         string  `json:"id"`
	Identifier *string `json:"identifier"`
}

type VideoFile struct {
	ID  string `json:"id"`
	URL string `json:"url"`
}

func (VideoFile) IsFile()             {}
func (this VideoFile) GetID() string  { return this.ID }
func (this VideoFile) GetURL() string { return this.URL }

type CollectionDefaultContent string

const (
	CollectionDefaultContentLyrics CollectionDefaultContent = "lyrics"
	CollectionDefaultContentSheets CollectionDefaultContent = "sheets"
	CollectionDefaultContentTracks CollectionDefaultContent = "tracks"
)

var AllCollectionDefaultContent = []CollectionDefaultContent{
	CollectionDefaultContentLyrics,
	CollectionDefaultContentSheets,
	CollectionDefaultContentTracks,
}

func (e CollectionDefaultContent) IsValid() bool {
	switch e {
	case CollectionDefaultContentLyrics, CollectionDefaultContentSheets, CollectionDefaultContentTracks:
		return true
	}
	return false
}

func (e CollectionDefaultContent) String() string {
	return string(e)
}

func (e *CollectionDefaultContent) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CollectionDefaultContent(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CollectionDefaultContent", str)
	}
	return nil
}

func (e CollectionDefaultContent) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CollectionDefaultSort string

const (
	CollectionDefaultSortTitle    CollectionDefaultSort = "title"
	CollectionDefaultSortNumber   CollectionDefaultSort = "number"
	CollectionDefaultSortAuthor   CollectionDefaultSort = "author"
	CollectionDefaultSortComposer CollectionDefaultSort = "composer"
	CollectionDefaultSortGenre    CollectionDefaultSort = "genre"
)

var AllCollectionDefaultSort = []CollectionDefaultSort{
	CollectionDefaultSortTitle,
	CollectionDefaultSortNumber,
	CollectionDefaultSortAuthor,
	CollectionDefaultSortComposer,
	CollectionDefaultSortGenre,
}

func (e CollectionDefaultSort) IsValid() bool {
	switch e {
	case CollectionDefaultSortTitle, CollectionDefaultSortNumber, CollectionDefaultSortAuthor, CollectionDefaultSortComposer, CollectionDefaultSortGenre:
		return true
	}
	return false
}

func (e CollectionDefaultSort) String() string {
	return string(e)
}

func (e *CollectionDefaultSort) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CollectionDefaultSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CollectionDefaultSort", str)
	}
	return nil
}

func (e CollectionDefaultSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ParticipantType string

const (
	ParticipantTypeAuthor   ParticipantType = "author"
	ParticipantTypeComposer ParticipantType = "composer"
	ParticipantTypeArranger ParticipantType = "arranger"
	ParticipantTypeArtist   ParticipantType = "artist"
	ParticipantTypeEditor   ParticipantType = "editor"
)

var AllParticipantType = []ParticipantType{
	ParticipantTypeAuthor,
	ParticipantTypeComposer,
	ParticipantTypeArranger,
	ParticipantTypeArtist,
	ParticipantTypeEditor,
}

func (e ParticipantType) IsValid() bool {
	switch e {
	case ParticipantTypeAuthor, ParticipantTypeComposer, ParticipantTypeArranger, ParticipantTypeArtist, ParticipantTypeEditor:
		return true
	}
	return false
}

func (e ParticipantType) String() string {
	return string(e)
}

func (e *ParticipantType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ParticipantType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ParticipantType", str)
	}
	return nil
}

func (e ParticipantType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SheetClef string

const (
	SheetClefAlto   SheetClef = "alto"
	SheetClefTreble SheetClef = "treble"
	SheetClefBass   SheetClef = "bass"
)

var AllSheetClef = []SheetClef{
	SheetClefAlto,
	SheetClefTreble,
	SheetClefBass,
}

func (e SheetClef) IsValid() bool {
	switch e {
	case SheetClefAlto, SheetClefTreble, SheetClefBass:
		return true
	}
	return false
}

func (e SheetClef) String() string {
	return string(e)
}

func (e *SheetClef) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SheetClef(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SheetClef", str)
	}
	return nil
}

func (e SheetClef) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SheetContent string

const (
	SheetContentLead      SheetContent = "lead"
	SheetContentLyrics    SheetContent = "lyrics"
	SheetContentFullScore SheetContent = "fullScore"
	SheetContentFivePart  SheetContent = "fivePart"
	SheetContentSmallBand SheetContent = "smallBand"
)

var AllSheetContent = []SheetContent{
	SheetContentLead,
	SheetContentLyrics,
	SheetContentFullScore,
	SheetContentFivePart,
	SheetContentSmallBand,
}

func (e SheetContent) IsValid() bool {
	switch e {
	case SheetContentLead, SheetContentLyrics, SheetContentFullScore, SheetContentFivePart, SheetContentSmallBand:
		return true
	}
	return false
}

func (e SheetContent) String() string {
	return string(e)
}

func (e *SheetContent) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SheetContent(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SheetContent", str)
	}
	return nil
}

func (e SheetContent) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SheetFileType string

const (
	SheetFileTypeMusicxml SheetFileType = "musicxml"
	SheetFileTypePDF      SheetFileType = "pdf"
)

var AllSheetFileType = []SheetFileType{
	SheetFileTypeMusicxml,
	SheetFileTypePDF,
}

func (e SheetFileType) IsValid() bool {
	switch e {
	case SheetFileTypeMusicxml, SheetFileTypePDF:
		return true
	}
	return false
}

func (e SheetFileType) String() string {
	return string(e)
}

func (e *SheetFileType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SheetFileType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SheetFileType", str)
	}
	return nil
}

func (e SheetFileType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SheetSize string

const (
	SheetSizeLarge  SheetSize = "large"
	SheetSizeMedium SheetSize = "medium"
	SheetSizeSmall  SheetSize = "small"
)

var AllSheetSize = []SheetSize{
	SheetSizeLarge,
	SheetSizeMedium,
	SheetSizeSmall,
}

func (e SheetSize) IsValid() bool {
	switch e {
	case SheetSizeLarge, SheetSizeMedium, SheetSizeSmall:
		return true
	}
	return false
}

func (e SheetSize) String() string {
	return string(e)
}

func (e *SheetSize) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SheetSize(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SheetSize", str)
	}
	return nil
}

func (e SheetSize) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Status string

const (
	StatusPublished Status = "published"
	StatusUnlisted  Status = "unlisted"
)

var AllStatus = []Status{
	StatusPublished,
	StatusUnlisted,
}

func (e Status) IsValid() bool {
	switch e {
	case StatusPublished, StatusUnlisted:
		return true
	}
	return false
}

func (e Status) String() string {
	return string(e)
}

func (e *Status) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Status(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Status", str)
	}
	return nil
}

func (e Status) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
